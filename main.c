#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <stdint.h>
#include <stddef.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

/*
 * afl-cc -O0 -g -static -Wl,--warn-unresolved-symbols -Wl,--unresolved-symbols=report-all main.c  kernel-mocker-v2.c linux/crypto/asymmetric_keys/pkcs8_parser.o linux/lib/asn1_decoder.o linux/crypto/asymmetric_keys/pkcs8.asn1.o
 * 
 */

// Structs copied from the kernel code
#define __rcu
union key_payload {
	void __rcu		*rcu_data0;
	void			*data[4];
};

struct key_preparsed_payload {
	const char	*orig_description; /* Actual or proposed description (maybe NULL) */
	char		*description;	/* Proposed key description (or NULL) */
	union key_payload payload;	/* Proposed payload */
	const void	*data;		/* Raw data */
	size_t		datalen;	/* Raw datalen */
	size_t		quotalen;	/* Quota length for proposed payload */
	uint64_t	expiry;		/* Expiry time of key */
};

extern int pkcs8_key_preparse(struct key_preparsed_payload *prep);

// Parse data generated by fuzzer into fields for the target. Probably should start using libfuzzer
#define BYTE(x) do { \
	if (len < 0) { \
		printf("LEN IS NEGATIVE: %d\n",len); \
		exit(0);\
	} \
	if (len == 0) {  \
		printf("Len is 0, exiting\n"); \
		exit(0);  \
	} \
	x = (uint8_t)(*buf); \
	buf++; \
	len--; \
} while (0);

#define DATA(x, l) do { \
	uint8_t l2; \
	BYTE(l2);				  \
	if (l2 >= len) {			  \
		printf("LEN TOO LARGE: %d >= %d\n",l2,len); \
		exit(0);\
	}							  \
	x = buf;					  \
	l = l2;\
	buf += l2;					  \
	len -= l2;\
} while (0);

#define STR_TERMINATED(x) do { \
	uint8_t l2; \
	DATA(x, l2); \
	buf[-1] = 0x00; \
} while (0);

// Read from file in argv1 and run the function
int main(int argc, char* argv[]) {
	
	int    fd = -1;
	int  len;
	char * buf = NULL;
	size_t n_read;
	int    result = -1;
	
    fd = open(argv[1], O_RDONLY);
    if (fd < 0) { perror("open"); exit(0); }
    len = lseek(fd, 0, SEEK_END);
    if (len < 0) { perror("lseek (SEEK_END)"); exit(0); }
    if (lseek(fd, 0, SEEK_SET) != 0) { perror("lseek (SEEK_SET)"); exit(0); }
    buf = (char *)malloc(len);
    if (buf == NULL) { perror("malloc"); exit(0); }
    n_read = read(fd, buf, len);
    if (n_read != len) { perror("read"); exit(0); }
   
	struct key_preparsed_payload p;
	STR_TERMINATED(p.orig_description);
	STR_TERMINATED(p.description);
	STR_TERMINATED(p.payload.data[0]);
	STR_TERMINATED(p.payload.rcu_data0);
	DATA(p.data, p.datalen);
	BYTE(p.quotalen);
	BYTE(p.expiry);
	printf("orig_desc: %s\n",p.orig_description);
	printf("description: %s\n",p.description);
	printf("payload.rcu_data0: %p\n",p.payload.rcu_data0);
	printf("payload.data[0]: %p\n",p.payload.data[0]);
	printf("quotalen: %ld\n",p.quotalen);
	printf("expiry: %ld\n",p.expiry);
	printf("At: %c, Len: %d\n",*buf, len);
	pkcs8_key_preparse(&p);
}
